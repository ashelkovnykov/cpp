# Design

This library documents C++ language design principles and examples of standard/professional/good C++ programming techniques.

## Principles

### Zero-overhead Principle

The "zero-overhead" principle of C++ states:
1. You don't pay for what you don't use
2. What you do use is just as efficient as what you could reasonably write by hand

In practice, this means that no feature should be added to C++ which imposes an overhead (in terms of time or space) greater than what would be introduced if a programmer attempted to accomplish the same action without the feature.

There are two exceptions to the zero-overhead principle: runtime type identification and exceptions. As such, most compilers allow both of these features to be disabled.

## Techniques

### Generating Exceptions

**Exceptions should only be generated by functions, and only for the following reasons:**
1. **Failure to meet function pre-conditions**
2. **Failure to meet function post-conditions**

Classes should be structured so that providing bad input is not an option. If this is impossible, then the input validation should be encapsulated in a function (likely the constructor), and the rule will still hold.

### Rule of Three

**If a class requires a user-defined destructor, copy constructor, or copy assignment operator, then it requires all three.**

C++ typically copies and copy-assigns objects frequently, meaning that the copy constructor and copy assignment operator are frequently invoked. Classes that do not have a user-defined copy constructor or copy assignment operator will have one automatically generated by the compiler. However, for classes which manage resources such as pointers to heap allocated objects or file descriptors (the typical use cases that require a custom destructor) the default copy constructor/assignment operator perform "shallow" copies (i.e. they copy the pointer to the resource, not the resource itself). Therefore, a custom destructor warrants custom copy constructors and assignment operators, and a custom copy constructor warrants a custom copy assignment operator (and vice-versa).

On the other hand, if a class deals with resources such that custom copy constructors and assignment operators are necessary, it's almost certain that the destructor for this class needs to perform some custom duties, whether it be releasing resources or announcing that it is no longer using them.

### Rule of Five

**Any class for which user-defined move semantics are desirable should declare all five of the following: destructor, copy constructor, move constructor, copy assignment operator, and move assignment operator.**

A user-defined destructor, copy constructor, or copy assignment operator prevents the compiler from automatically implementing a move constructor and move assignment operator. Therefore, implementing the Rule of Three will cause move semantics to be missing in a situation which may benefit from them. Therefore, a custom move constructor or move assignment operator typically warrants all five of the aforementioned functions. Unlike the Rule of Three, breaking the Rule of Five rarely results in errors; it is a missed optimization opportunity.

#### Corollary

**If you must `= default` or `= delete` one of the destructor, copy constructor, copy assignment operator, move constructor, or move assignment operator, then `= default` or `= delete` them all.**

### Rule of Zero

**If you can avoid defining the destructor, copy constructor, copy assignment operator, move constructor, and move assignment operator, do so.**

The Rule of Zero is the contrapositive of the Rule of Three and the Rule of Five. The aim is to keep class behaviour simple or default whenever possible.

### Resource Acquisition is Initialization

1. **Encapsulate each resource into a class where:**
    - **The constructor acquires the resource or throws an exception that it cannot be done**
    - **The destructor releases the resource and never throws exceptions**
2. **Always use the resource via an instance of the above class that either:**
    - **Has automatic storage duration; OR**
    - **Has lifetime bounded by an object with automatic storage duration**

This is a technique which binds the lifecycle of resources that exist in limited supply and must be acquired before use to the lifetime of an object. Doing so guarantees that the resource is available to any object/function which can access the binding object, and that the resource is released when the lifetime of the bound object ends. RAII leverages the C++ native features of lifetime, scope, order of initialization, and stack unwinding to eliminate resource leaks. Another name for RAII is "Scope-Bound Resource Management".
