# Templates

This library documents C++ templates.

A template defines a family of classes, functions, or variables. They are parameterized by one or more template parameters. Each template parameter is either a type, an object, or another template. During compilation, specific classes/functions/variables are generated from the templates by the compiler using template parameter arguments that are either directly provided or indirectly deduced.

A template by itself is not a type, object, or any other entity. Instead, it is a user-generated pattern for the compiler to use when instantiating specific template family members.

## Member Templates

Templates which appear inside of a non-local class are known as "member templates". These templates define a family of classes, functions, or variables which are members of the class that holds the template.

### Member Function Templates

Member function templates cannot instantiate copy constructors or destructors. They cannot produce or override virtual functions. Template member functions and non-template member functions may be declared with the same name: in this case, the non-template member function takes priority.

### Member Variable Templates

Template data members are always instantiated as static data members.

## Explicit Instantiation

Instead of implicit instantiation through use, a template specialization may also be explicitly instantiated. The explicit instantiation may appear anywhere in the program, so long as it appears after the template definition. If the explicit instantiation is not just a declaration, but also an explicit definition, it must be in the same translation unit as the template definition.

Explicit instantiation skips implicit instantiation: the code that would normally cause implicit instantiation instead calls the code generated by the explicit instantiation. This can be used to save space by making explicit instantiation declarations in all translation units except one, which will contain the instantiation code (as opposed to each translation unit having an identical version of the instantiated template code).

### Partial Specialization

Class templates can be "partially specialized". Partial specialization is like explicit instantiation, except that only some (not all) of the template arguments are set.

When instantiating a class template, the compiler will choose the most specialized variant available. Therefore, the compiler prioritizes template specializations as such:
1. Explict instantiation
2. Partial specialization (most specialized to least specialized)
3. Unspecialized

## Deduction Guides

Template deduction guides are patterns associated with a template which tell the compiler how to translate one set of template arguments (deduced from the arguments class constructor or function) into another. During implicit template instantiation, the deduced template arguments will be matched against the set of deduction guides. If a matching deduction guide is found, the template arguments specified by the guide will replace those that were deduced automatically. Afterwards, instantiation proceeds as normal.

## Parameter Packs

A template parameter pack is a template parameter that accepts zero or more arguments. Parameter packs can be expanded within the template body. Parameter pack expansion has different meaning depending on the context in which it is done, so that it works correctly for various potential use cases (e.g. Function arguments, member initializer lists, expressions, etc.).

A Parameter pack must be the final parameter in the template parameter list.

## Concepts & Constraints

A "constraint" is a sequence of one or more logical operations/operands that specifies requirements on template arguments which must be met for template instantiation to occur. Violation of a constraint is detected at compile time. A constraint can be named for use with multiple templates; a named constraint is called a "concept". The primary purpose of a concept is to model semantic categories (e.g. Number, Range, Date, etc.) as opposed to syntactic restrictions (e.g. HasPlusFunc, Immutable, etc.).
